<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Types and Time</title>

		<link rel="stylesheet" href="revealjs/dist/reset.css">
		<link rel="stylesheet" href="revealjs/dist/reveal.css">
		<link rel="stylesheet" href="revealjs/dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="revealjs/plugin/highlight/stackoverflow-light.css">

		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section>
	<img width="50%" src="images/cover-image.jpg">
	<h3 style="text-transform: none;">Types and Time</h3>
	<h5 style="text-transform: none;">Languages, Tools, and Methods<br>for Reliable Systems Engineering</h5>
	<p>Nikolaus Huber</p>
</section>

<section>
	<h5>Contributions</h5>
	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">Mimosa: A Language for Asynchronous Implementation of Embedded Systems Software</div>
			<div class="contr-authors"><b>Huber N.</b>, Graf S., Rümmer P., Yi W.</div>
		</div>
		<div class="contr-badges">
			<img class="contr-badge" src="images/coordination_functional.png">
			<img class="contr-badge" src="images/coordination_available.png">
		</div>
	</div>

	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">Compiling the Mimosa Programming Language to RTOS Tasks</div>
			<div class="contr-authors"><b>Huber N.</b>, Graf S., Rümmer P., Yi W.</div>
		</div>
	</div>

	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">Dynamic Verification of OCaml Software with Gospel and Ortac/QCheck-STM</div>
			<div class="contr-authors"><b>Huber N.</b>, Spargo N., Osborne N., Hym S., Midtgaard J.</div>
		</div>
		<div class="contr-badges">
			<img class="contr-badge" src="images/etaps_reusable.svg">
			<img class="contr-badge" src="images/etaps_available.svg">
		</div>
	</div>

	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">An Encoding of Interaction Nets in OCaml</div>
			<div class="contr-authors"><b>Huber N.</b>, Yi W.</div>
		</div>
	</div>
</section>

<section>
	<img width="80%" src="images/v_diagram_papers.jpg">
</section>

<section>
	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">Mimosa: A Language for Asynchronous Implementation of Embedded Systems Software</div>
			<div class="contr-authors"><b>Huber N.</b>, Graf S., Rümmer P., Yi W.</div>
		</div>
		<div class="contr-badges">
			<img class="contr-badge" src="images/coordination_functional.png">
			<img class="contr-badge" src="images/coordination_available.png">
		</div>
	</div>

	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">Compiling the Mimosa Programming Language to RTOS Tasks</div>
			<div class="contr-authors"><b>Huber N.</b>, Graf S., Rümmer P., Yi W.</div>
		</div>
	</div>

	<div class="artifact-container">
		<span class="artifact-title">Artifact:</span>
		<div class="doi-badge">
			<span class="label">DOI</span>
			<a class="value" href="https://doi.org/10.5281/zenodo.14963241" target="_blank">10.5281/zenodo.14963241</a>
		</div>
	</div>
</section>

<section>
	<img width="80%" src="images/mimos_gps_example-page_1.png">
</section>

<section>
	<img width="80%" src="images/mimos_gps_example-page_2.png">
</section>

<section>
	<img width="80%" src="images/mimos_gps_example-page_3.png">
</section>

<section>
	<img width="80%" src="images/mimos_gps_example-page_4.png">
</section>

<section>
	<img width="80%" src="images/mimos_gps_example-page_5.png">
</section>

<section>
	<img width="80%" src="images/mimos_gps_example-page_6.png">
</section>

<section>
	<h3>Motivation</h3>
	<ul>
		<li class="fragment fade-up">Synchronous paradigm</li>
		<ul>
			<li class="fragment fade-up">Lustre/SCADE, Esterel, Signal, ...</li>
			<li class="fragment fade-up">safety-critical embedded control</li>
		</ul>
		<li class="fragment fade-up">Modern execution platforms</li>
		<ul>
			<li class="fragment fade-up">Multi- & many-core processors</li>
			<li class="fragment fade-up">distributed systems</li>
		</ul>
		<li class="fragment fade-up">(Safe) updates?</li>
	</ul>
</section>

<section>
	<h3>Mimos</h3>
	<img class="r-stretch" src="images/mimos_model.jpg">
	<div style="margin-top: 1rem;" class="citation">
		<div class="cite">Mimos: A Deterministic Model for the Design and Update of Real-Time Systems</div>
		<div class="source">Wang Yi, Morteza Mohaqeqi, Susanne Graf<br>
			International Conference on Coordination Languages and Models (COORDINATION 2022)</div>
	</div>
</section>

<section>
	<h3>Our contribution</h3>

	<ul>
		<li class="fragment fade-up">MIMOS Application language (Mimosa)</li>
		<li class="fragment fade-up">Focus on formal semantics</li>
		<li class="fragment fade-up">Naturally divides into</li>
		<ul>
			<li class="fragment fade-up">Semantics for computation</li>
			<li class="fragment fade-up">Semantics for coordination</li>
		</ul>
		<li class="fragment fade-up">Prototype simulator</li>
		<li class="fragment fade-up">Compilation scheme</li>
	</ul>
</section>

<section data-auto-animate>
	<img width="80%" src="images/fib_example.png" />
	<pre class="text"><code data-trim data-noescape data-line-numbers="|1|2,3|5-8|10-12|">
		step print_int (_ : int) --> ()
		step add (x, y) --> z { z = x + y }
		step split x --> (o1, o2, o3) { o1, o2, o3 = x, x, x }

		channel a : int = { 1 }
		channel b : int = { 0 }
		channel c : int
		channel d : int

		node add implements add (a, c) --> (b) every 10ms
		node split implements split (b) --> (a, d, c) every 10ms
		node print implements print_int (d) --> () every 10ms
	</code></pre>
</section>

<section>
	<span style="font-size: 60%">
	$$\small
	\begin{align*}
	\begin{array}{rcll}
	e : \text{Expression} & ::= & x & \text{Variable} \\
	{} & | & c & \text{Constant} \\
	{} & | & e\bm{,}\, \ldots\bm{,}\, e & \text{Tuple} \\
	{} & | & \textbf{pre}\, e & \text{Pre} \\
	{} & | & e\, \bm{\rightarrow}\, e & \text{Initialized-by} \\
	{} & | & e\, \textbf{fby}\, e & \text{Followed-by} \\
	{} & | & e\, e & \text{Application} \\
	{} & | & \textbf{if}\, e\, \textbf{then}\, e\, \textbf{else}\, e & \text{Conditional} \\
	{} & | & \textbf{None} & \text{None} \\
	{} & | & \textbf{Some}\, e & \text{Some} \\
	{} & | & \textbf{either}\, e\, \textbf{or}\, e & \text{Option match} \\
	{} & | & \bm{\lambda}_{p_{in}}^{p_{out}} \bm{.} [p_i = e_i]^n & \text{Abstraction} \\
	p : \text{Pattern} & ::= & x & \text{Variable pattern} \\
	{} & | & p\bm{,}\, \ldots\bm{,}\, p & \text{Tuple pattern}
	\end{array}
	\end{align*}$$
	</span>
</section>

<section>
	<h3>Design choices</h3>
	<ul>
		<li class="fragment fade-up">Memory operators</li>
	<li class="fragment fade-up" style="list-style-type: none;"><span style="font-size: 1.2rem;">
	\[
	\begin{array}{c|llll}
	{} & 1 & 2 & 3 & \cdots \\ 
	\hline
	x & x_1 & x_2 & x_3 & \cdots \\
	y & y_1 & y_2 & y_3 & \cdots \\
	\textbf{pre}\; x & \bot & x_1 & x_2 & \cdots \\
	x\, \bm{\rightarrow}\, y & x_1 & y_2 & y_3 & \cdots \\
	x\; \textbf{fby}\; y & x_1 & y_1 & y_2 & \cdots
	\end{array}
	\]
	</span></li>

	<li class="fragment fade-up">Selective evaluation:
	<ul>
		<span style="font-size: 1.5rem">$\textbf{if}/\textbf{then}/\textbf{else}$</span>, <span style="font-size:1.5rem;">$\textbf{either}/\textbf{or}$</span>, <span style="font-size:1.5rem;">$\textbf{fby}$</span></li>
	</ul>
	<li class="fragment fade-up">Expression evaluation might cause side effects</li>

</section>

<!-- <section>
	<h3>Environments</h3>
	<span style="font-size: 80%">
	$$\Gamma \quad \subseteq \quad \textbf{Names} \times \textbf{Values}$$
	</span>

	<h5 class="fragment fade-up" style="text-align: left;">Projection</h5>
	<span class="fragment fade-up" style="font-size: 70%">
	\[\begin{align*}(x \mapsto 1, y \mapsto 2) \Downarrow_x\; &=\; 1 \\
	(x \mapsto 1, y \mapsto 2) \Downarrow_{(x, y)}\; &=\; (1, 2)\end{align*}\]
	</span>
	<h5 class="fragment fade-up" style="text-align: left;">Update</h5>
	<span class="fragment fade-up" style="font-size: 70%">
	\[\begin{align*}(x \mapsto 1, y \mapsto 2) \Uparrow_z^3\; &=\; (x \mapsto 1, y \mapsto 2, z \mapsto 3) \\
	(x \mapsto 1, y \mapsto 2) \Uparrow_{(x, y)}^{(3, 4)}\; &=\; (x \mapsto 3, y \mapsto 4)\end{align*}\]
	</span>
</section> -->

<section>
	<h3>Step semantics</h3>
	<ul>
		<li class="fragment fade-up">How to model state?</li>
		<li class="fragment fade-up">Big-step + rewrite semantics</li>
	</ul>
	<span class="fragment fade-up">\[\Gamma \vdash e \Rightarrow v, e'\]</span>
</section>

<section>
	<span style="font-size: 35%">
	\[
	\begin{gather*}
	\begin{aligned}
	\frac{}{\Gamma \vdash x \Rightarrow \Gamma \Downarrow_x, x}\; \texttt{\small (Var)}
	& \; &
	\frac{}{\Gamma \vdash c \Rightarrow c, c}\; \texttt{\small (Const)}
	& \; &
	\frac{\Gamma \vdash e \Rightarrow v, e'}{\Gamma \vdash \textbf{pre}\, e \Rightarrow \bot, (v \rightarrow \textbf{pre}\, e')}\; \texttt{\small (Pre)}
	\end{aligned} \\[4mm]
	\begin{aligned}
	\frac{\Gamma \vdash e_1 \Rightarrow v_1, \text{\textunderscore}}{\Gamma \vdash e_1\, \textbf{fby}\, e_2 \Rightarrow v_1, e_2}\; \texttt{\small (Fby)}
	& \; &
	\frac{\Gamma \vdash e_1 \Rightarrow v_1, \text{\textunderscore} \qquad \Gamma \vdash e_2 \Rightarrow \text{\textunderscore}, e_2'}{\Gamma \vdash (e_1 \bm{\rightarrow} e_2) \Rightarrow v_1, e_2'}\; \texttt{\small (Init)}
	\end{aligned} \\[4mm]
	\frac{\Gamma \vdash e_1 \Rightarrow v_1, e_1' \qquad \ldots \qquad \Gamma \vdash e_n \Rightarrow v_n, e_n'}{\Gamma \vdash (e_1, \ldots, e_n) \Rightarrow (v_1, \ldots, v_n), (e_1', \ldots, e_n')}\; \texttt{\small (Tuple)} \\[4mm]
	\frac{\Gamma \vdash e_1 \Rightarrow \textbf{True}, e_1' \qquad \Gamma \vdash e_2 \Rightarrow v, e_2'}{\Gamma \vdash \textbf{if}\, e_1\, \textbf{then}\, e_2\, \textbf{else}\, e_3 \Rightarrow v, \textbf{if}\, e_1'\, \textbf{then}\, e_2'\, \textbf{else}\, e_3}\; \texttt{\small (IfTrue)} \\[4mm]
	\frac{\Gamma \vdash e_1 \Rightarrow \textbf{False}, e_1' \qquad \Gamma \vdash e_3 \Rightarrow v, e_3'}{\Gamma \vdash \textbf{if}\, e_1\, \textbf{then}\, e_2\, \textbf{else}\, e_3 \Rightarrow v, \textbf{if}\, e_1'\, \textbf{then}\, e_2\, \textbf{else}\, e_3'}\; \texttt{\small (IfFalse)} \\[4mm]
	\begin{aligned}
	\frac{}{\Gamma \vdash \textbf{None} \Rightarrow \textbf{None}, \textbf{None}}\; \texttt{\small (None)}
	& \; &
	\frac{\Gamma \vdash e \Rightarrow v, e'}{\Gamma \vdash \textbf{Some}\, e \Rightarrow \textbf{Some}\, v, \textbf{Some}\, e'}\; \texttt{\small (Some)}
	\end{aligned} \\[4mm]
	\begin{aligned}
	\frac{\Gamma \vdash e_1 \Rightarrow \textbf{Some}\, v, e_1'}{\Gamma \vdash (\textbf{either}\, e_1\, \textbf{or}\, e_2) \Rightarrow v, (\textbf{either}\, e_1'\, \textbf{or}\, e_2)}\; \texttt{\small (EthrSome)}
	& \; &
	\frac{\Gamma \vdash e_1 \Rightarrow \textbf{None}, e_1' \qquad \Gamma \vdash e_2 \Rightarrow v, e_2'}{\Gamma \vdash (\textbf{either}\, e_1\, \textbf{or}\, e_2) \Rightarrow v, (\textbf{either}\, e_1'\, \textbf{or}\, e_2')}\; \texttt{\small (EthrNone)}
	\end{aligned} \\[4mm]
	\frac{\Gamma \vdash e_1 \Rightarrow \bm{\lambda}_{p_{in}}^{p_{out}} \bm{.} [p_i = e_i]^n, \text{\textunderscore} \qquad \Gamma \vdash e_2 \Rightarrow v_2, e_2' \qquad \Gamma \Uparrow_{p_{in}}^{v_2} \vdash [p_i = e_i]^n \hookrightarrow [p_i = e_i']^n, \Gamma'}{\Gamma \vdash e_1\; e_2 \Rightarrow \Gamma' \Downarrow_{p_{out}}, (\bm{\lambda}_{p_{in}}^{p_{out}} \bm{.} [p_i = e_i']^n)\; e_2'}\; \texttt{\small (App)} \\[4mm]
	\frac{\Gamma' \vdash e_1 \Rightarrow v_1, e_1' \qquad \ldots \qquad \Gamma' \vdash e_n \Rightarrow v_n, e_n'}{\Gamma \vdash [p_i = e_i]^n \hookrightarrow [p_i = e_i']^n, \Gamma' = \Gamma \Uparrow_{p_1}^{v_1} \cdots \Uparrow_{p_n}^{v_n}}\; \texttt{\small (Eqs)}
	\end{gather*}
	\]
	</span>
</section>

<!-- <section>
	<span style="font-size: 70%">
	\[
	\begin{gather*}
	\frac{}{\Gamma \vdash x \Rightarrow \Gamma \Downarrow_x, x}\; \texttt{\small (Var)} \\[0.6cm]
	\frac{}{\Gamma \vdash c \Rightarrow c, c}\; \texttt{\small (Const)}
	\end{gather*}
	\]
	</span>
</section> -->

<section>
	<span style="font-size: 70%">
	\[
	\begin{gather*}
	\frac{\Gamma \vdash e \Rightarrow v, e'}{\Gamma \vdash \textbf{pre}\, e \Rightarrow \bot, (v \rightarrow \textbf{pre}\, e')}\; \texttt{\small (Pre)} \\[0.6cm]
	\frac{\Gamma \vdash e_1 \Rightarrow v_1, \text{\textunderscore}}{\Gamma \vdash e_1\, \textbf{fby}\, e_2 \Rightarrow v_1, e_2}\; \texttt{\small (Fby)} \\[0.6cm]
	\frac{\Gamma \vdash e_1 \Rightarrow v_1, \text{\textunderscore} \qquad \Gamma \vdash e_2 \Rightarrow \text{\textunderscore}, e_2'}{\Gamma \vdash (e_1 \bm{\rightarrow} e_2) \Rightarrow v_1, e_2'}\; \texttt{\small (Init)}
	\end{gather*}
	\]
	</span>
</section>

<!-- <section>
	<span style="font-size: 50%">
	\[
	\begin{gather*}
	\frac{\Gamma \vdash e_1 \Rightarrow \bm{\lambda}_{p_{in}}^{p_{out}} \bm{.} [p_i = e_i]^n, \text{\textunderscore} \qquad \Gamma \vdash e_2 \Rightarrow v_2, e_2' \qquad \Gamma \Uparrow_{p_{in}}^{v_2} \vdash [p_i = e_i]^n \hookrightarrow [p_i = e_i']^n, \Gamma'}{\Gamma \vdash e_1\; e_2 \Rightarrow \Gamma' \Downarrow_{p_{out}}, (\bm{\lambda}_{p_{in}}^{p_{out}} \bm{.} [p_i = e_i']^n)\; e_2'}\; \texttt{\small (App)} \\[0.8cm]
	\frac{\Gamma' \vdash e_1 \Rightarrow v_1, e_1' \qquad \ldots \qquad \Gamma' \vdash e_n \Rightarrow v_n, e_n'}{\Gamma \vdash [p_i = e_i]^n \hookrightarrow [p_i = e_i']^n, \Gamma' = \Gamma \Uparrow_{p_1}^{v_1} \cdots \Uparrow_{p_n}^{v_n}}\; \texttt{\small (Eqs)}
	\end{gather*}
	\]
	</span>
</section> -->

<section>
	<img width="50%" src="images/rewriting_fifo.png" />
</section>

<section>
	<h3>Simulation</h3>
	<ul>
		<li class="fragment fade-up">Deep embedding into OCaml</li>
		<li class="fragment fade-up">Step evaluation &rarr; direct translation</li>
		<li class="fragment fade-up">Node execution &rarr; discrete-event simulation</li>
		<li class="fragment fade-up">Step prototypes &rarr; OCaml functor</li>
	</ul>
</section>

<section>
	<img width="70%" src="images/mimos_layers.jpg">
</section>

<section>
	<h3>Step Compiler overview</h3>
	<img width="70%" src="images/compiler_overview.jpg">
</section>

<section>
	<h3>Future work</h3>
	<ul>
		<li class="fragment fade-up">Extension of type system</li>
		<ul>
			<li class="fragment fade-up">float, double, strings, ...</li>
			<li class="fragment fade-up">algebraic data-types</li>
		</ul>
		<li class="fragment fade-up">Additional read/write strategies</li>
		<ul>
			<li class="fragment fade-up">Registers</li>
			<li class="fragment fade-up">Upto-k</li>
		</ul>
		<li class="fragment fade-up">Effect type system</li>
	</ul>
	<pre class="fragment fade-up"><code data-trim data-noescape class="language-text">
		step print_int (_ : int) -[ IO ]-> ()
	</code></pre>
</section>

<section>
	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">Dynamic Verification of OCaml Software with Gospel and Ortac/QCheck-STM</div>
			<div class="contr-authors"><b>Huber N.</b>, Spargo N., Osborne N., Hym S., Midtgaard J.</div>
		</div>
		<div class="contr-badges">
			<img class="contr-badge" src="images/etaps_reusable.svg">
			<img class="contr-badge" src="images/etaps_available.svg">
		</div>
	</div>

	<div class="artifact-container">
		<span class="artifact-title">Artifact:</span>
		<div class="doi-badge">
			<span class="label">DOI</span>
			<a class="value" href="https://doi.org/10.5281/zenodo.13988146" target="_blank">10.5281/zenodo.13988146</a>
		</div>
	</div>

	<div style="margin-top: 2rem;">
		<img width="30%" src="images/tarides-logo.svg">
	</div>
</section>

<section>
	<p><img width="20%" src="images/colour-logo.png"></p>
	<ul>
		<li class="fragment fade-up">Caml (ML dialect) + OO</li>
		<li class="fragment fade-up">Functional core</li>
		<li class="fragment fade-up">Many <em>imperative features</em></li>
		<ul>
			<li class="fragment fade-up">References</li>
			<li class="fragment fade-up">Mutable arrays</li>
			<li class="fragment fade-up">I/O</li>
			<li class="fragment fade-up">Exceptions</li>
		</ul>
	</ul>
</section>

<section>
	<img class="fragment fade-up" width="250em" src="images/logo-rocq-orange_blue.png" /><br>
	<img class="fragment fade-up" width="250em" src="images/frama-c.png" /><br>
	<div class="fragment fade-up" style="display:flex; flex-direction: row; justify-content: center; align-items: center; gap: 2%">
		<img width="50em" src="images/logo-2.png" /> 
		<p>Infer</p>
	</div>
	<p class="fragment fade-up">Astrée</p>
	<h3 class="fragment fade-up">...</h3>
</section>

<section>
	<h3>Gospel</h3>
	<ul>
		<li class="fragment fade-up">Behavioural specification language</li>
		<ul>
			<li class="fragment fade-up">ACSL, JML, ...</li>
		</ul>
		<li class="fragment fade-up">Type invariants, function pre/post conditions, mutability, exceptions, ...</li>
		<li class="fragment fade-up">Tool agnostic</li>
		<ul>
			<li class="fragment fade-up">Cameleer</li>
			<li class="fragment fade-up">Why3gospel</li>
			<li data-id="ortac" class="fragment fade-up">ORTAC</li>
			<li class="fragment fade-up">...</li>
		</ul>
	</ul>
</section>

<section>
	<h3 data-id="ortac">ORTAC</h3>
	<ul>
		<li class="fragment fade-up"><strong>(O)</strong>Caml <strong>(R)</strong>un<strong>(T)</strong>ime <strong>(A)</strong>ssertion <strong>(C)</strong>hecker</li>
		<li class="fragment fade-up">Module I/F + GOSPEL <span class=fragment fade-up">&rArr; code for testing</span></li>
		<li class="fragment fade-up">Plugins</li>
		<ul>
			<li class="fragment fade-up">Wrapper</li>
			<li class="fragment fade-up">Monolith</li>
			<li class="fragment fade-up">QCheck-STM</li>
			<li class="fragment fade-up">...</li>
		</ul>
	</ul>
</section>

<section>
	<h3>QCheck-STM</h3>
	<ul>
		<li class="fragment fade-up">QCheck + state</li>
		<li class="fragment fade-up">black-box, model-based state-machine testing</li>
	</ul>
	<img width="70%" class="fragment fade-up" src="images/pbt.drawio.png" />
</section>

<section>
	<img width="70%" src="images/ortac_overview.drawio.png" />
</section>

<section>
	<h3>Stack (Excerpt)</h3>
	<pre><code data-trim data-noescape data-line-numbers class="language-ocaml">
		type 'a t
		
		exception Empty
		
		val create : unit -> 'a t
		val push : 'a -> 'a t -> unit
		val pop : 'a t -> 'a
		val is_empty : 'a t -> bool
	</code></pre>
</section>

<section>
	<pre class="fragment fade-up"><code data-trim data-noescape data-line-numbers class="language-ocaml">
		type 'a t
		(*@ mutable model contents : 'a sequence *)
	</code></pre>

	<pre class="fragment fade-up"><code data-trim data-noescape data-line-numbers data-ln-start-from="6" class="language-ocaml">
		val create : unit -> 'a t
		(*@ t = create ()
			  ensures t.contents = Sequence.empty *)
	</code></pre>

	<pre class="fragment fade-up"><code data-trim data-noescape data-line-numbers data-ln-start-from="10" class="language-ocaml">
		val push : 'a -> 'a t -> unit
		(*@ push v t
				modifies t.contents
				ensures t.contents =
					Sequence.cons v (old t.contents) *)
	</code></pre>

	<pre class="fragment fade-up"><code data-trim data-noescape data-line-numbers data-ln-start-from="52" class="language-ocaml">
		val is_empty : 'a t -> bool
		(*@ b = is_empty t
				ensures b = match Sequence.length t.contents with
				  | 0 -> true
				  | _ -> false *)
	</code></pre>
</section>

<section>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		val copy : 'a t -> 'a t
		(*@ r = copy t
				ensures r.contents = t.contents *)
	</code></pre>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		val transfer : 'a t -> 'a t -> unit
		(*@ transfer t1 t2
				modifies t1.contents
				modifies t2.contents
				ensures t1.contents = Sequence.empty
				ensures t2.contents =
					(old t1.contents) ++ (old t2.contents) *)
	</code></pre>
</section>

<section>
	<img class="r-stretch" src="images/sut_stack.drawio.png" />
</section>

<section>
	<h3>Evaluation - Errors/Bugs found</h3>
</section>

<section>
	<h3>Hashtbl</h3>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		val create : ?random:bool -> int -> ('a, 'b) t
		(** [Hashtbl.create n] creates an empty hash table, with
			initial size [n]. For best results, [n] should be on the
			order of the expected number of elements that will be in
			the table.  The table grows as needed, so [n] is just an
			initial guess. ... *)
	</code></pre>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		type ('a, 'b) t
		(*@ mutable model contents : ('a * 'b) list *)

		val create : ?random:bool -> int -> ('a, 'b) t
		(*@ h = create ?random size
				checks size >= 0
				ensures h.contents = [] *)
	</code></pre>
</section>

<section>
	<pre><code data-trim data-noescape class="language-text">
		Gospel specification violation in function create

		File "hashtbl.mli", line 7, characters 11-20:
			size >= 0
		when executing the following sequence of operations:

		[@@@ocaml.warning "-8"]
		open Hashtbl
		let protect f = try Ok (f ()) with e -> Error e
		let sut0 = create ~random:false 16
		let r = protect (fun () -> create ~random:true (-8))
		assert (match r with
					| Error (Invalid_argument _) -> true
					| _ -> false)
		(* returned Ok (<sut>) *)
	</code></pre>
</section>

<section>
	<h3>Errors found</h3>
	<ul>
		<li class="fragment fade-up">Documentation fix</li>
		<ul>
			<li class="fragment fade-up"><em>Hashtbl.create</em> (initial size guess can be negative)</li>
		</ul>
		<li class="fragment fade-up">2 bugs in <em>Varray</em> library
		<li class="fragment fade-up">7 bugs in <em>Bitv</em> library</li> 
		<ul>
			<li class="fragment fade-up">3 functions with possible integer overflow</li>
			<li class="fragment fade-up">2 functions with possible division-by-zero</li>
			<li class="fragment fade-up">2 functions throwing unexpected exceptions</li>
		</ul>
		<li class="fragment fade-up">...</li>
	</ul>
</section>

<section>
	<h3>Evaluation - API coverage</h3>
</section>

<section>
	<img class="r-stretch" src="images/api_coverage.png" />
</section>

<section>
	<h3>Future work</h3>
	<ul>
		<li class="fragment fade-up">Aliased SUT arguments</li>
		<li class="fragment fade-up">Higher-order functions (<span style="font-style: italic;">map, fold, iter</span>)</li>
		<li class="fragment fade-up">Utilise <span style="font-style: italic;">requires</span> clause for command generation</li>
		<li class="fragment fade-up">Parallel testing</li>
	</ul>
</section>


<section>
	<div class="contr-box">
		<div class="contr-paper">
			<div class="contr-title">An Encoding of Interaction Nets in OCaml</div>
			<div class="contr-authors"><b>Huber N.</b>, Yi W.</div>
		</div>
	</div>
	<div class="artifact-container">
		<span class="artifact-title">Artifact:</span>
		<div class="doi-badge">
			<span class="label">DOI</span>
			<a class="value" href="https://doi.org/10.5281/zenodo.12633477" target="_blank">10.5281/zenodo.12633477</a>
		</div>
	</div>
</section>

<section>
	<h3>Generalised Algebraic Data Types</h3>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		type expr =
			| Lit of int
			| Eq of expr * expr
			| If of expr * expr * expr
	</code></pre>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers data-ln-start-from="5">
		let rec eval (e : expr) : ??? = ...
	</code></pre>
</section>

<section>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		type _ expr =
			| Lit : int -> int expr
			| Eq : int expr * int expr -> bool expr
			| If : bool expr * 'a expr * 'a expr -> 'a expr
	</code></pre>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers data-ln-start-from="5">
		let rec eval : type a. a expr -> a = function
			| Lit n -> n
			| Eq (e1, e2) -> (eval e1) = (eval e2)
			| If (e1, e2, e3) -> 
					if (eval e1) then (eval e2) else (eval e3)
	</code></pre>
	
</section>

<section data-auto-animate>
	<h3>Graph rewriting</h3>
	<img width="50%" src="images/graph_rewriting_rule.png">
</section>

<section data-auto-animate>
	<div>
		<img width="30%" src="images/graph_rewriting_rule.png">
	</div>
	<div>
		<img width="50%" src="images/graph_rewriting_application.png">
	</div>
</section>

<section data-auto-animate>
	<div>
		<img width="30%" src="images/graph_rewriting_rule.png">
	</div>
	<div>
		<img width="50%" src="images/graph_rewriting_application.png">
	</div>
	<div>
		<p>sub-graph isomorphism problem &rArr; NP-complete</p>
	</div>
</section>

<section>
	<h3>Interaction nets</h3>
	<ul>
		<li class="fragment fade-up">Specific form of graph rewriting</li>
		<li class="fragment fade-up">Visual programming language</li>
		<li class="fragment fade-up">Invented by Yves Lafont</li>
		<li class="fragment fade-up">Many interesting properties</li>
	</ul>
</section>

<section>
	<h3>Interaction net primitives</h3>
	<ul>
		<li class="fragment fade-up" style="list-style-type: none;">Agents:</li>
		<li style="list-style-type: none;">
			<div style="align-items: center; display: flex;">
				<img class="fragment fade-up" style="margin-left: 5rem;" width="30%" src="images/agent-examples.png">
					<span class="fragment fade-up" style="font-size: 80%; margin-left: 7rem;">
						\[\begin{align*}
						\Sigma &= \{\alpha, \beta, \gamma\} \\
						\textbf{ar} &: \Sigma \rightarrow \mathbb{N}
						\end{align*}\]
					</span>
			</div>
		</li>
		<li class="fragment fade-up" style="list-style-type: none;">Rules:</li>
		<li style="list-style-type: none;"><img class="fragment fade-up" style="margin-left: 5rem;" width="60%" src="images/inet-rule.png"></li>
	</ul>
</section>

<section>
	<h3>Example - Arithmetic</h3>
	<div>
		<img class="fragment fade-up" width="30%" src="images/inet-arith-agents.png">
	</div>
	<div>
		<img class="fragment fade-up" style="padding-right: 5rem;" width="30%" src="images/inet-arith-add-zero.png">
		<img class="fragment fade-up" width="40%" src="images/inet-arith-add-one.png">
	</div>
</section>

<section>
	<img width="30%" src="images/inet-arith-ex1.png">
</section>

<section>
	<img width="30%" src="images/inet-arith-ex2.png">
</section>

<section>
	<!-- <div>
		<img width="30%" style="opacity: 30%;" src="images/inet-arith-add-one.png">
	</div> -->
	<div>
		<img width="52%" src="images/inet-arith-ex3.png">
	</div>
</section>

<section>
	<img width="30%" src="images/inet-arith-ex4.png">
</section>

<section>
	<img width="50%" src="images/inet-arith-ex5.png">
</section>

<section>
	<img width="70%" src="images/inet-arith-more-agents.png">
</section>

<section>
	<h3>Typing Issues</h3>
	<img width="30%" src="images/inet-arith-typing-issues.png">
</section>

<section>
	<h3>Lafont's Type System</h3>
	<img width="45%" src="images/inet-arith-more-agents-type.png">
</section>

<section>
	<h3>Properties</h3>
	<ul>
		<li class="fragment fade-up">Locality<span class="fragment fade-up"> &rArr; parallel evaluation</span></li>
		<li class="fragment fade-up">Easy to indentify pattern graphs</li>
		<li class="fragment fade-up">No overlapping rules<span class="fragment fade-up"> &rArr; strong confluence</span></li>
	</ul>
</section>

<section>
	<h3>Motivation</h3>
	<ul>
		<li class="fragment fade-up">No previous encoding in OCaml</li>
		<li class="fragment fade-up">Most existing encodings focus on efficiency</li>
		<li class="fragment fade-up">Focus on type system</li>
		<li class="fragment fade-up">Can we express this type system in OCaml?</li>
		<li class="fragment fade-up">Can we make use of OCaml's support for parallelism?</li>
	</ul>
</section>

<section>
	<img width="40%" src="images/inet-arith-agents-type.png">
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers>
		type pos = |
		type neg = |
	</code></pre>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers data-ln-start-from="3">
		type (_, _) agent =
			| Z : (int, pos) agent
			| S : (int, pos) agent -> (int, pos) agent
			| Plus : (int, neg) agent * (int, pos) agent -> 
							 (int, neg) agent
	</code></pre>
	<pre class="fragment fade-up OCaml"><code data-trim data-noescape data-line-numbers data-ln-start-from="8">
		let ( -><- ) : type a . 
			(a, pos) agent -> (a, neg) agent -> unit = (* ... *)
	</code></pre>
</section>

<section>
	<h3>Evaluation - Speedup</h3>
	<img width="70%" src="images/speedup-perf.png">
</section>

<section>
	<h3>Evaluation - Fibonacci</h3>
	<img width="70%" src="images/inet-fib-ex.png">
</section>

<section>
	<h3>Future work</h3>
	<ul>
		<li class="fragment fade-up">Investigate performance</li>
		<li class="fragment fade-up">Try different parallel runtime libraries</li>
		<li class="fragment fade-up">Compilation to interaction nets</li>
		<ul>
			<li class="fragment fade-up">OCaml <span style="font-style: italic;">extension nodes</span>?</li>
			<li class="fragment fade-up">Compiling Mimosa to interaction nets?</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Thank you</h3>
</section>

<!--
<section>
	<h3>Additional slides</h3>
</section>

<section>
	<h3 style="text-transform: none;">NormIR</h3>
	<span style="font-size:50%">
	\[
	\begin{align*}
	\begin{array}{rcll}
	b : \text{Base} & ::= & x & \text{Variable} \\
	{} & | & c & \text{Constant} \\
	{} & | & \textbf{None} & \text{None} \\
	{} & | & \textbf{Some}\, x & \text{Some} \\
	e : \text{Expression} & ::= & b & \text{Base expression} \\
	{} & | & x\bm{,}\, \ldots\bm{,}\, x & \text{Tuple} \\
	{} & | & \textbf{pre}\, x & \text{Pre} \\
	{} & | & bl\, \textbf{fby}\, bl & \text{Followed-by} \\
	{} & | & x\, x & \text{Application} \\
	{} & | & \textbf{if}\, x\, \textbf{then}\, bl\, \textbf{else}\, bl & \text{Conditional} \\
	{} & | & \textbf{either}\, x\, \textbf{or}\, bl & \text{Option match} \\
	bl : \text{Block} & ::= & [\, p_i\, =\, e_i\, ]^n,\, b & \text{Block}
	\end{array}
	\end{align*}
	\]
	</span>
</section>

<section>
	<h3>Normalisation</h3>
	<div style="margin-top: 3rem"></div>
	<span style="font-size: 30%">
	\[
	\begin{gather*}%
    \begin{aligned}
    % Variables
    \frac%
    { }%
    {x\, \Rrightarrow\, [\;],\, x}% 
    \; \texttt{\small (Var)}%
    & \; &
    % Constants
    & \frac%
    { }%
    {c\, \Rrightarrow\, [\;],\, c}%
    \; \texttt{(Const)}%
    & \; &
    % Some
    \frac%
    { e\, \Rrightarrow\, s,\, e' }%
    { \textbf{Some}\, e\, \Rrightarrow\, (s\, ::\, [\, \langle r \rangle\, =\, \textbf{Some}\, e'\,]), \, \langle r \rangle}%
    \; \texttt{(Some)} %
    \end{aligned}\\[4mm]%
    \begin{aligned}
    % None
    \frac%
    { }%
    { \textbf{None}\, \Rrightarrow\, [\;],\, \textbf{None} }%
    \; \texttt{(None)}
    & \; &
    % Init
    \frac%
    {e_1\, \Rrightarrow b \qquad e_2\, \Rrightarrow\, s_2,\, e_2'}%
    {{e_1\, \rightarrow\, e_2}\, \Rrightarrow\, {(s_2\, :: [\, \langle y \rangle\, =\, e_2';\, \langle r \rangle\, =\, b\, \textbf{fby}\, ([\;],\, \langle y \rangle)\,])},\, {\langle r\rangle}}%
    \; \texttt{(Init)}
    \end{aligned}\\[4mm]%
    \begin{aligned}
    % Pre
    \frac%
    {{e}\, \Rrightarrow {s},\,{e'}}%
    {\textbf{pre}\,e\, \Rrightarrow\, (s \, ::\, [\, \langle x \rangle \,=\, e';\, \langle r \rangle \,=\, \textbf{pre}\, \langle x \rangle \,]),\, \langle r \rangle}%
    \; \texttt{(Pre)}%
    & \quad &
    % Fby
    \frac%
    {e_1\, \Rrightarrow\, b_1 \qquad e_2\, \Rrightarrow\, b_2}%
    {{e_1\, \textbf{fby}\, e_2}\, \Rrightarrow {[\,\langle r \rangle\, =\, b_1\, \textbf{fby}\, b_2\,]},\,{\langle r \rangle}}%
    \; \texttt{(Fby)}%
    \end{aligned} \\[4mm]%
    % Tuples
    \frac%
    {{e_1}\, \Rrightarrow {s_1},\, {e_1'} \qquad \ldots \qquad {e_n}\, \Rrightarrow {s_n},\, {e_n'}}%
    {e_1,\, \ldots,\, e_n\, \Rrightarrow\, (s_1\, :: \ldots\, ::\, s_n\, ::
    [\,\langle t_1 \rangle\, =\, e_1';\, \ldots;\, \langle t_n \rangle\, =\, e_n';\, \langle r \rangle\, =\, \langle t_1 \rangle,\, \ldots,\, \langle t_n \rangle\,]),\, \langle r \rangle}
    \; \texttt{(Tuple)} \\[4mm]%
    % If-then-else
    \frac%
    {{e_1}\, \Rrightarrow {s},\, {e_1'} \qquad e_2\, \Rrightarrow\, b_2 \qquad e_3\, \Rrightarrow\, b_3}%
    {\textbf{if}\, e_1\, \textbf{then}\, e_2 \, \textbf{else}\, e_3\, \Rrightarrow (s\, ::\, [\, \langle x \rangle\, =\, e_1';\, \langle r\rangle\, =\, \textbf{if}\, \langle x \rangle\, \textbf{then}\, b_2\, \textbf{else}\, b_3\,]),\,\langle r \rangle
    }%
    \; \texttt{(If)} \\[4mm]%
    \begin{aligned}
    % Either-or
    \frac%
    {e_1\, \Rrightarrow\, s,\, e_1' \qquad e_2\, \Rrightarrow\, b}%
    {\textbf{either}\, e_1\, \textbf{or}\, e_2\, \Rrightarrow (s\, ::\, [ \, \langle x \rangle\, =\, e_1';\, \langle r \rangle\, =\, \textbf{either}\, \langle x \rangle\, \textbf{or}\, b\, ]),\, \langle r \rangle}%
    \; \texttt{(Either)} %
    & \; &
    % Application
    \frac%
    {e_1\, =\, f \qquad e_2\, \Rrightarrow\, s,\, e_2'}%
    {e_1 \; e_2 \, \Rrightarrow\, (s\, ::\, [\, \langle x \rangle\, =\, e_2';\, \langle r \rangle\, =\, f\; \langle x \rangle\,]),\, \langle r \rangle}%
    \; \texttt{(App)}
    \end{aligned}%
	\end{gather*}
	\]
	</span>
</section>

<section>
	<h3>Step normalisation</h3>
	<div style="margin-top: 3rem"></div>
	<span style="font-size: 40%">
		\[
		\begin{gather*}
		\textbf{step}\, name\, \bm{(}\, i_1\bm{,}\, \ldots\bm{,}\, i_l\, \bm{)}\, \bm{\longrightarrow}\, \bm{(}\, o_1\bm{,}\, \ldots\bm{,}\, o_k\, \bm{)}\, [\, p_i\, =\, e_i\, ]^n\\
		\Downarrow \\
		e_1\, \Rrightarrow\, s_1,\, e_1' \qquad \ldots \qquad e_n\, \Rrightarrow\, s_n,\, e_n' \\
		\Downarrow \\
		\textbf{step}\, name\, \langle in \rangle\, \bm{\longrightarrow}\, \langle out \rangle\, (
		\left (
		\begin{array}{c}
			[\, i_1\bm{,}\, \ldots\bm{,}\, i_l\, =\, \langle in \rangle\,]\\
			\vdots \\
			::\, s_i\, ::\, [\, p_i\, =\, e_i'\, ]\, :: \\
			\vdots \\
			\left [\, \langle out \rangle\, =\, o_1\bm{,}\, \ldots\bm{,}\, o_k\, \right ]
		\end{array}
		\right )
		, \langle out \rangle )
		\end{gather*}
		\]
	</span>
</section>

<section>
	<h3>OOIR</h3>
	<span style="font-size: 50%">
		\[
		\begin{align*}
		\begin{array}{rcll}
		e : \text{Expression} & ::= & x & \text{Variable} \\
		{} & | & \textbf{!}\, x & \text{State variable} \\
		{} & | & c & \text{Constant} \\
		{} & | & \textbf{None} & \text{None} \\
		{} & | & \textbf{Some}\, x & \text{Some} \\
		i : \text{Instruction} & ::= & x\, =\, e & \text{Assignment} \\
		{} & | & x\, \bm{\leftarrow}\, e & \text{State assignment} \\
		{} & | & x\, =\, x\bm{,}\, \ldots\bm{,}\, x & \text{Tuple construction} \\
		{} & | & x\bm{,}\, \ldots\bm{,}\, x\, =\, x & \text{Tuple destruction} \\
		{} & | & x.\textbf{reset} (\, x\, ) & \text{State reset} \\
		{} & | & \textbf{return}\, e & \text{Return} \\
		{} & | & \textbf{if}\, x\, \textbf{then}\, [\, i\,]\,  \textbf{else}\, [\, i\, ] & \text{Conditional} \\
		{} & | & x\, =\, x.\textbf{step}\, \bm{(}\, x,\, x\, \bm{)} & \text{Application} \\
		{} & | & \textbf{case}\, x\, \bm{\ \{} \, \textbf{Some}\, x:\, [\, i \,]; \textbf{None}: \, [\, i \,]\, \textbf{\}} & \text{Option match} \\
		d : \text{Machine} & ::= & (\, m,\, j,\, r,\, s\, ) & {} \\
		m,\, j & ::= & [\, x \,] & {} \\
		r,\, s & ::= & [\, i\, ]
		\end{array}
		\end{align*}
		\]
	</span>
</section>

<section>
	<h3 style="text-transform: none;">NormIR &rarr; OOIR</h3>
	<span style="font-size: 30%">
		\[
		\begin{gather*}
		\begin{aligned}
		\frac{ }{ m \triangleright c \rightsquigarrow c }\; \texttt{(Const)} & \quad &
		\frac{ v \notin m }{ m \triangleright v \rightsquigarrow v}\; \texttt{(Var)} & \quad &
		\frac{ v \in m}{ m \triangleright v \rightsquigarrow \textbf{!}\, v}\; \texttt{(StateVar)} & \quad &
		\frac{ }{m \triangleright \textbf{None} \rightsquigarrow \textbf{None}}\; \texttt{(None)} \end{aligned}\\[5mm]
		\begin{aligned}
		\frac{ }{ m \triangleright \textbf{Some}\, v \rightsquigarrow \textbf{Some}\,v} \; \texttt{(Some)} & \quad &
		\frac%
		{ m \triangleright e \rightsquigarrow e' }%
		{ (m, j, r, s) \triangleright v = e \Rightarrow (m, j, r, (s ::\, [\, v = e'\,]))}%
		\; \texttt{(Base)}
		\end{aligned} \\[5mm]
		\frac{(m, j, r, [\;]) \triangleright s_t \Rightarrow (m', j', r', s_t') \qquad m' \triangleright e_t \rightsquigarrow e_t' \qquad (m', j', r', [\;]) \triangleright s_e \Rightarrow (m'', j'', r'', s_e') \qquad m'' \triangleright e_e \rightsquigarrow e_e'}%
		{ (m,j,r,s) \triangleright x = \textbf{if}\, c\, \textbf{then}\, (s_t, e_t)\, \textbf{else}\, (s_e, e_e) \Rightarrow (m'', j'', r'', (s\, :: \, [\, \textbf{if}\, c\, \textbf{then}\, (s_t'\, ::\, [\, x\, =\, e_t'\,])\, \textbf{else}\, (s_e'\, ::\, [\, x\, =\, e_e'\,])\,])) }%
		\; \texttt{(If)} \\[5mm]
		\frac%
		{}%
		{(m, j, r, s) \triangleright v = \textbf{pre}\, x \Rightarrow ((m\, ::\, [\, \langle tmp \rangle\,]), j, (r\, ::\, [\,\langle tmp \rangle \bm{\leftarrow} nil\,]), (s \, ::\, [\, v = \textbf{!}\, \langle tmp \rangle;\, \langle tmp \rangle \bm{\leftarrow} x \,]))}
		\; \texttt{(Pre)} \\[5mm]
		\frac%
		{(m, j, r, [\;]) \triangleright s_1 \Rightarrow (m', j', r', s_1') \qquad m' \triangleright e_1 \rightsquigarrow e_1' \qquad (m', j', r', [\;]) \triangleright s_2 \Rightarrow (m'', j'', r'', s_2') \qquad m'' \triangleright e_2 \rightsquigarrow e_2'}%
		{{\begin{array}{c}(m, j, r, s) \triangleright v = (s_1, e_1) \, \textbf{fby}\, (s_2, e_2) \Rightarrow \\ ((m''\, ::\, [\,\langle \mathit{fst} \rangle\,]), j'', (r''\, :: \, [\, \langle \mathit{fst} \rangle \bm{\leftarrow} true \,]), (s\, ::\, [\, \langle t \rangle = \textbf{!}\, \langle \mathit{fst} \rangle;\, \textbf{if}\, \langle t \rangle\, \textbf{then}\, (s'\, ::\, [\, v = e_1'\,])\, \textbf{else}\, (s''\, ::\, [\, v = e_2'\,]);\, \langle \mathit{fst} \rangle \bm{\leftarrow} false\,]))\end{array}}}
		\; \texttt{(Fby)} \\[10mm]
		\frac%
		{(m,j,r,[\;]) \triangleright s \Rightarrow (m', j', r', s') \qquad m' \triangleright e \rightsquigarrow e'}%
		{(m,j,r,s) \triangleright v = \textbf{either}\, x\, \textbf{or}\, (s, e) \Rightarrow (m', j', r', (s\, ::\, [\, \textbf{case}\, x\, \bm{\{} \textbf{Some}\, y: [\, v = y\, ]; \textbf{None}: (s'\, ::\, [\, v = e'\,] \bm{\}}]))}%
		\; \texttt{(Either)} \\[5mm]
		\frac%
		{ }%
		{ (m,j,r,s) \triangleright v = \mathrm{f}\, x \Rightarrow (m, (j\, ::\, [\, \langle o \rangle\,]), (r\, ::\, [\, \mathrm{f}.\textbf{reset} (\, \langle o \rangle\, )\,]), (s\, ::\, [ \, x = \mathrm{f}.\textbf{step} (\, x,\, \langle o \rangle\, )\,]))}
		\; \texttt{(App)} \\[5mm]
		\frac{ }{(m, j, r, s) \triangleright v = x_1, \ldots, x_n \Rightarrow (m, j, r, (s\, ::\, [\, v = x_1, \ldots, x_n\,]))}\; \texttt{(TupleConstr)} \\[5mm]
		\frac%
		{ (m, j, r, s) \triangleright \langle t \rangle = e \Rightarrow (m', j', r', s') }%
		{ (m,j,r,s) \triangleright v_1\bm{,}\, \ldots\bm{,}\, v_n = e \Rightarrow (m',j',r', (s'\, ::\, [\, v_1\bm{,}\, \ldots\bm{,}\, v_n = \langle t \rangle\, ]))}%
		\; \texttt{(TupleDestr)}
		\end{gather*}
		\]
	</span>
</section>

-->

			</div>
		</div>

		<script src="revealjs/dist/reveal.js"></script>
		<script src="revealjs/plugin/notes/notes.js"></script>
		<script src="revealjs/plugin/markdown/markdown.js"></script>
		<script src="revealjs/plugin/highlight/highlight.js"></script>
		<script src="revealjs/plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: "c",
				transition: "fade",
				controls: false,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>
